#include <M5Atom.h>
#include <PubSubClient.h>
#include <HTTPUpdate.h>

const char* MQTT_SERVER = "broker.emqx.io";
const uint16_t MQTT_PORT = 1883;

WiFiClient wifiClient;
PubSubClient mqttClient(wifiClient);
String clientId;

const char DRAW_TOPIC[] = "steffiPeTaffy/draw";
const char CONNECT_TOPIC[] = "steffiPeTaffy/draw/connect";
const char UPDATE_TOPIC[] = "steffiPeTaffy/draw/update";

uint8_t data[5][5][3] = {0}; // Adjusted for 5x5 matrix

void setup() {
    M5.begin(true, false, true);
    Serial.begin(115200);

    M5.dis.fillpix(0x000000); // Clear Matrix
    M5.dis.show();

    clientId = "M5AtomClient-" + String(random(0xffff), HEX);

    mqttClient.setServer(MQTT_SERVER, MQTT_PORT);
    mqttClient.setCallback(callback);
}

void sync() {
    Serial.println("Syncing...");
    uint8_t payload[5];

    for (uint8_t x = 0; x < 5; x++) {
        for (uint8_t y = 0; y < 5; y++) {
            if (data[x][y][0] == 0 && data[x][y][1] == 0 && data[x][y][2] == 0) continue;
            
            payload[0] = x;
            payload[1] = y;
            payload[2] = data[x][y][0];
            payload[3] = data[x][y][1];
            payload[4] = data[x][y][2];
            mqttClient.publish(DRAW_TOPIC, payload, sizeof(payload));
        }
    }
}

void callback(char* topic, byte* message, unsigned int length) {
    Serial.print("Message received on topic: ");
    Serial.println(topic);

    if (strcmp(topic, DRAW_TOPIC) == 0) {
        if (length != 5) {
            Serial.print("Invalid message length: ");
            Serial.println(length);
            return;
        }

        uint8_t x = message[0] % 5;
        uint8_t y = message[1] % 5;
        uint32_t color = M5.dis.color444(message[2] >> 4, message[3] >> 4, message[4] >> 4);

        data[x][y][0] = message[2];
        data[x][y][1] = message[3];
        data[x][y][2] = message[4];

        M5.dis.drawpix(x + y * 5, color);
        M5.dis.show();
    } else if (strcmp(topic, CONNECT_TOPIC) == 0) {
        sync();
    } else if (strcmp(topic, UPDATE_TOPIC) == 0) {
        update(message);
    } else {
        Serial.print("Unknown topic: ");
        Serial.println(topic);
    }
}

void reconnect() {
    while (!mqttClient.connected()) {
        Serial.print("Connecting to MQTT...");
        if (mqttClient.connect(clientId.c_str())) {
            Serial.println("Connected!");
            mqttClient.subscribe(DRAW_TOPIC);
            mqttClient.subscribe(CONNECT_TOPIC);
            mqttClient.subscribe(UPDATE_TOPIC);
            sync();
        } else {
            Serial.print("MQTT connection failed, rc=");
            Serial.print(mqttClient.state());
            Serial.println(". Retrying in 5 seconds...");
            delay(5000);
        }
    }
}

void update(byte* message) {
    String tagName = String((char*)message);
    Serial.printf("Updating to version: %s\n", tagName.c_str());

    t_httpUpdate_return ret = httpUpdate.update(wifiClient, "http://github.com/SteffiPeTaffy/draw/releases/download/" + tagName + "/firmware.bin");

    switch (ret) {
        case HTTP_UPDATE_FAILED:
            Serial.printf("HTTP Update Failed (%d): %s\n", httpUpdate.getLastError(), httpUpdate.getLastErrorString().c_str());
            break;
        case HTTP_UPDATE_NO_UPDATES:
            Serial.println("No updates found.");
            break;
        case HTTP_UPDATE_OK:
            Serial.println("Update successful!");
            break;
    }
}

void loop() {
    if (!mqttClient.connected()) {
        reconnect();
    }
    mqttClient.loop();
}
